#+TITLE: Bug-induced Upgrade
#+DATE:
#+AUTHOR: wuxh
#+OPTIONS: timestamp:nil
#+OPTIONS: ^:{}
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="org_modify.css"/>



* Overview
** Goal
   There exist some library upgrade which would break client. Among them lots of cases are due to
   the co-evolution of libraries. We aim to find those bug-induced upgrade.

   Given a client (and its dependencies), generate a patch on POM to upgrade a certain library / certain libraries,
   so that some client tests (used to pass) would fail with upgraded dependencies.

** NaÃ¯ve approach / groundtruth
   Upgrade each library and run tests.
   Our approach should be more efficient than this brute-force approach.
** Current idea
   To reduce the cycles of upgrade-runtest,
   cluster / partition all dependencies (maybe include transitive) as weakly-connected (directed) sub-graphs,
   so that multiple combinations can be pruned after one upgrade-runtest cycle.

** Algorithm
   #+begin_src C
// INPUT: c - a client
D_a = DependencyGraph(c) // pom
D_b = RunAnalysis() // codeQL query
G = ConstructGraph(D_a, D_b)
G_0, ..., G_n = Partition(G) // a set of sub-graphs
While (any of G_i is not empty) do
    For i = 0 to n do
	L_i = Prioritise(G_i)
    done
    DoUpgrade([L_i for i = 0 to n])
    T = SelectTest()
    suc, trace = RunTest(T)
    if suc is false then
	if Verify(trace) is true then
	    return
    else
	Prune(G_0, ..., G_n)
done
   #+end_src

** How to reduce search space

** Client issues
* Partition strategy / ideas
** Mine references used in POMs
   Those library whose versions are configured use the same reference should have strong
   connection.
** Static analysis on client
   Find highly-related libraries, based on their mutual presence and/or data dependency in a
   client method.

* Interaction Pattern (where conflicts happen)
+ JAR ?
+ POM:
+ data: e.g. jacoco-core, jacoco-report
+ client usage
* Future Plan
+ Upgrade pairs to find conflicts caused by two (or more) dependencies


* Maven Dependency Plugin
** Verbose option
   =-Dverbose= option was removed since =maven-dependency-plugin:3.0= for Maven 3 compatibility.
** copy-dependency

** unpack-dependencies
   We could use this option to directly unpack jars instead of doing it manually.

* Dataflow Analysis with CodeQL
** Step
#+begin_src sh
codeql database create project.db --language=java
codeql database analyze project.db ~/codeql-repo/java/ql/src/datadp.ql  --output=/tmp/a.csv --format=csv
codeql bqrs decode --format=csv -o project.csv project.db/results/codeql-java/datadp.bqrs
#+end_src
** Current issues (but can be solved in the merging step)
   + [X] Not filter client class: can do it in the later steps
   + [ ] Filter java std lib (why =notJavaLib/1= is not applied on =isSink/1=)
   + [X] Not work when using codeql command line tools (path-problem result patterns?)
	 - refer to [[#manual-decode-bqrs]] for solutions
   + [ ] Can =notSameJar/2= be improved?

** DONE How to get query results with CLT
   :PROPERTIES:
   :CUSTOM_ID: manual-decode-bqrs
   :END:
   - State "DONE"       from "TODO"       [2021-01-20 Wed 15:37]
When the query does not conform with the format of path query, =interpret-results= does not work.
However, we can always invoke =bqrs decode --format=csv -o results.csv datadp.bqrs=, generating a
CSV of query results.
** TODO What does TaintTracking in codeql do?

* Add dataflow analysis results in pomdep graph
** Multiple G-A-V in one JAR
   + (fuzzy) match class path against group_id/artifact_id
     - now: split by dot and do set intersection (class_name in csv ^ class_path in JAR)
** On determining Mvn-Coord of a JAR
   + Some JAR do not include =pom.properties=
   + Some JAR do not include =META-INF= directory, at least =MANIFEST.MF= can be used to determine artifact id
   + If found nothing, just use the JAR name
	 - [ ] can at least prune version string

** Match coord with nodes in pomdep graph
   + full match (g,a,v) first
   + if failed, match artifact_id only
   + if failed, skip


* Class-level graph
  + [ ] Classes in which package
  + [ ] Class reference: datalog

    
* Cases Inspection
** java-driver
   + On the target version (tag =4.3.0=), expected dependency 
   =slf4j.LoggerFactory -> logback.classic.Logger= does not appear in
   codeql query results.
   
   + Modify query script with location report.

   + Try to checkout to newer version =4.x=, run the same query again,
   found similar dependency in another file.

#+begin_src java
public static LoggerSetup setupTestLogger(Class<?> clazz, Level levelToCapture) {
  @SuppressWarnings("unchecked")
  Appender<ILoggingEvent> appender = (Appender<ILoggingEvent>) mock(Appender.class);

  ArgumentCaptor<ILoggingEvent> loggingEventCaptor = ArgumentCaptor.forClass(ILoggingEvent.class);
  Logger logger = (Logger) LoggerFactory.getLogger(clazz);
  Level originalLoggerLevel = logger.getLevel();
  logger.setLevel(levelToCapture);
  logger.addAppender(appender);
  return new LoggerSetup(appender, originalLoggerLevel, logger, loggingEventCaptor);
}
#+end_src
   
which results in:
#+begin_src
"mock(...)","org.mockito.Mockito","addAppender(...)","ch.qos.logback.classic.Logger","LoggerTest:36[24-31]"
"getLogger(...)","org.slf4j.LoggerFactory","getLevel(...)","ch.qos.logback.classic.Logger","LoggerTest:34[33-38]"
"getLogger(...)","org.slf4j.LoggerFactory","setLevel(...)","ch.qos.logback.classic.Logger","LoggerTest:35[5-10]"
"getLogger(...)","org.slf4j.LoggerFactory","addAppender(...)","ch.qos.logback.classic.Logger","LoggerTest:36[5-10]"
"getLevel(...)","ch.qos.logback.classic.Logger","new LoggerSetup(...)","com.datastax.oss.driver.internal.core.util.LoggerTest$LoggerSetup","LoggerTest:37[38-56]"
#+end_src


But the following code (=DefaultLoadBalancingPolicyTestBase.java=) in both versions did not result in a record in query results:
#+begin_src java
@Before
  public void setup() {
    ...
    logger =
        (Logger) LoggerFactory.getLogger("com.datastax.oss.driver.internal.core.loadbalancing");
    logger.addAppender(appender);
    ...
  }
#+end_src
